// Generated by gencpp from file hivemind/Thrusters16.msg
// DO NOT EDIT!


#ifndef HIVEMIND_MESSAGE_THRUSTERS16_H
#define HIVEMIND_MESSAGE_THRUSTERS16_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace hivemind
{
template <class ContainerAllocator>
struct Thrusters16_
{
  typedef Thrusters16_<ContainerAllocator> Type;

  Thrusters16_()
    : header()
    , FXmMZm(0.0)
    , FXmMZp(0.0)
    , FYmMZm(0.0)
    , FYmMZp(0.0)
    , FXpMZm(0.0)
    , FXpMZp(0.0)
    , FYpMZm(0.0)
    , FYpMZp(0.0)
    , FZpMYm(0.0)
    , FZmMYp(0.0)
    , FZpMXp(0.0)
    , FZmMXm(0.0)
    , FZpMYp(0.0)
    , FZmMYm(0.0)
    , FZmMXp(0.0)
    , FZpMXm(0.0)  {
    }
  Thrusters16_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , FXmMZm(0.0)
    , FXmMZp(0.0)
    , FYmMZm(0.0)
    , FYmMZp(0.0)
    , FXpMZm(0.0)
    , FXpMZp(0.0)
    , FYpMZm(0.0)
    , FYpMZp(0.0)
    , FZpMYm(0.0)
    , FZmMYp(0.0)
    , FZpMXp(0.0)
    , FZmMXm(0.0)
    , FZpMYp(0.0)
    , FZmMYm(0.0)
    , FZmMXp(0.0)
    , FZpMXm(0.0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef float _FXmMZm_type;
  _FXmMZm_type FXmMZm;

   typedef float _FXmMZp_type;
  _FXmMZp_type FXmMZp;

   typedef float _FYmMZm_type;
  _FYmMZm_type FYmMZm;

   typedef float _FYmMZp_type;
  _FYmMZp_type FYmMZp;

   typedef float _FXpMZm_type;
  _FXpMZm_type FXpMZm;

   typedef float _FXpMZp_type;
  _FXpMZp_type FXpMZp;

   typedef float _FYpMZm_type;
  _FYpMZm_type FYpMZm;

   typedef float _FYpMZp_type;
  _FYpMZp_type FYpMZp;

   typedef float _FZpMYm_type;
  _FZpMYm_type FZpMYm;

   typedef float _FZmMYp_type;
  _FZmMYp_type FZmMYp;

   typedef float _FZpMXp_type;
  _FZpMXp_type FZpMXp;

   typedef float _FZmMXm_type;
  _FZmMXm_type FZmMXm;

   typedef float _FZpMYp_type;
  _FZpMYp_type FZpMYp;

   typedef float _FZmMYm_type;
  _FZmMYm_type FZmMYm;

   typedef float _FZmMXp_type;
  _FZmMXp_type FZmMXp;

   typedef float _FZpMXm_type;
  _FZpMXm_type FZpMXm;





  typedef boost::shared_ptr< ::hivemind::Thrusters16_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::hivemind::Thrusters16_<ContainerAllocator> const> ConstPtr;

}; // struct Thrusters16_

typedef ::hivemind::Thrusters16_<std::allocator<void> > Thrusters16;

typedef boost::shared_ptr< ::hivemind::Thrusters16 > Thrusters16Ptr;
typedef boost::shared_ptr< ::hivemind::Thrusters16 const> Thrusters16ConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::hivemind::Thrusters16_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::hivemind::Thrusters16_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace hivemind

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'geometry_msgs': ['/opt/ros/melodic/share/geometry_msgs/cmake/../msg'], 'std_msgs': ['/opt/ros/melodic/share/std_msgs/cmake/../msg'], 'hivemind': ['/home/jksun/surf-2019/jksun_ws/src/ros_hivemind/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::hivemind::Thrusters16_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::hivemind::Thrusters16_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::hivemind::Thrusters16_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::hivemind::Thrusters16_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::hivemind::Thrusters16_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::hivemind::Thrusters16_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::hivemind::Thrusters16_<ContainerAllocator> >
{
  static const char* value()
  {
    return "560359edb648a0c537e3d3a2564ae554";
  }

  static const char* value(const ::hivemind::Thrusters16_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x560359edb648a0c5ULL;
  static const uint64_t static_value2 = 0x37e3d3a2564ae554ULL;
};

template<class ContainerAllocator>
struct DataType< ::hivemind::Thrusters16_<ContainerAllocator> >
{
  static const char* value()
  {
    return "hivemind/Thrusters16";
  }

  static const char* value(const ::hivemind::Thrusters16_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::hivemind::Thrusters16_<ContainerAllocator> >
{
  static const char* value()
  {
    return "#Thruster values for the 16DOF (16 thruster) Spacecraft simulator\n"
"std_msgs/Header header\n"
"float32 FXmMZm\n"
"float32 FXmMZp\n"
"float32 FYmMZm\n"
"float32 FYmMZp\n"
"float32 FXpMZm\n"
"float32 FXpMZp\n"
"float32 FYpMZm\n"
"float32 FYpMZp\n"
"float32 FZpMYm\n"
"float32 FZmMYp\n"
"float32 FZpMXp\n"
"float32 FZmMXm\n"
"float32 FZpMYp\n"
"float32 FZmMYm\n"
"float32 FZmMXp\n"
"float32 FZpMXm\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::hivemind::Thrusters16_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::hivemind::Thrusters16_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.FXmMZm);
      stream.next(m.FXmMZp);
      stream.next(m.FYmMZm);
      stream.next(m.FYmMZp);
      stream.next(m.FXpMZm);
      stream.next(m.FXpMZp);
      stream.next(m.FYpMZm);
      stream.next(m.FYpMZp);
      stream.next(m.FZpMYm);
      stream.next(m.FZmMYp);
      stream.next(m.FZpMXp);
      stream.next(m.FZmMXm);
      stream.next(m.FZpMYp);
      stream.next(m.FZmMYm);
      stream.next(m.FZmMXp);
      stream.next(m.FZpMXm);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Thrusters16_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::hivemind::Thrusters16_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::hivemind::Thrusters16_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "FXmMZm: ";
    Printer<float>::stream(s, indent + "  ", v.FXmMZm);
    s << indent << "FXmMZp: ";
    Printer<float>::stream(s, indent + "  ", v.FXmMZp);
    s << indent << "FYmMZm: ";
    Printer<float>::stream(s, indent + "  ", v.FYmMZm);
    s << indent << "FYmMZp: ";
    Printer<float>::stream(s, indent + "  ", v.FYmMZp);
    s << indent << "FXpMZm: ";
    Printer<float>::stream(s, indent + "  ", v.FXpMZm);
    s << indent << "FXpMZp: ";
    Printer<float>::stream(s, indent + "  ", v.FXpMZp);
    s << indent << "FYpMZm: ";
    Printer<float>::stream(s, indent + "  ", v.FYpMZm);
    s << indent << "FYpMZp: ";
    Printer<float>::stream(s, indent + "  ", v.FYpMZp);
    s << indent << "FZpMYm: ";
    Printer<float>::stream(s, indent + "  ", v.FZpMYm);
    s << indent << "FZmMYp: ";
    Printer<float>::stream(s, indent + "  ", v.FZmMYp);
    s << indent << "FZpMXp: ";
    Printer<float>::stream(s, indent + "  ", v.FZpMXp);
    s << indent << "FZmMXm: ";
    Printer<float>::stream(s, indent + "  ", v.FZmMXm);
    s << indent << "FZpMYp: ";
    Printer<float>::stream(s, indent + "  ", v.FZpMYp);
    s << indent << "FZmMYm: ";
    Printer<float>::stream(s, indent + "  ", v.FZmMYm);
    s << indent << "FZmMXp: ";
    Printer<float>::stream(s, indent + "  ", v.FZmMXp);
    s << indent << "FZpMXm: ";
    Printer<float>::stream(s, indent + "  ", v.FZpMXm);
  }
};

} // namespace message_operations
} // namespace ros

#endif // HIVEMIND_MESSAGE_THRUSTERS16_H
